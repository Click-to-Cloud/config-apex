{"title":"Config.apex","githubRepo":"Click-to-Cloud/Config.apex","googleAnalytics":"","index":{"title":"Home","description":"Config.apex is a library to manage your configurations and cache in an elegant way.","content":" Unified API Config.apex offers a unified API to access configurations with difference sources. Good Integration Config.apex has integrations available with SObjects/CustomSettings. Cache Management Config.apex has a standalone CacheStore to provide easy-to-use and efficient cache system. ","srcFilePath":"src/pages/index.soy","id":"pages","location":"/./","url":"/config-apex/./","children":{"docs":{"title":"Docs","description":"Everything you need to know to get started.","content":" Docs Start learning how to leverage the power of . Choose a Guide Each one provide step by step coverage for every core feature. ","srcFilePath":"src/pages/docs/index.soy","id":"docs","location":"/docs/","url":"/config-apex/docs/","children":{"search":{"title":"Search","description":"Find what you're looking for in the documentation.","hidden":true,"content":" Electric Docs Start learning how to leverage the power of . ","srcFilePath":"src/pages/docs/search.soy","id":"search","location":"/docs/search.html","url":"/config-apex/docs/search.html"},"Config":{"title":"Config","description":"Config Service","layout":"guide","icon":"flash","weight":1,"content":" {$page.description} Background In a large system, we may encounter configurations from different sources. For example, we can store configurations in custom settings, or some custom SObjects. Even we can read configurations from external web services. So configurations are grouped by where they come from, and when we want to use the configs, we need to know their sources. However, what we ideally want is that our configurations are grouped by features and functions, and we don't want to be disturbed by where the configs come from and how we should access the configs. Under this background, we have the idea of building a config system, which provides a unified API that gives a consistent access to our configurations. Config Service With the purpose above, we built the Config Service, which behaves pretty much like the http service. Here are the factors involved in Config Service: Config URL A config service provider is bound to a specific config url. A config URL may be an exact String, or a pattern that matches a range of Strings, with variables starting with '${' and ending with '}'. Config Request A request for retrieving or updating the value of the configuration url. Like http requests, we can request a config url like this: /System/version?type=String Additional parameters may be specified. Also when it comes to the requests for updating, we can send the data of Map. Config requests are divided into two types: read(get) and write(put). Config Response For read config request, we respond with the value of the config. For write config request, the response is not used. Config Handler A config handler is a Func used to process the logic for config requests. Usually we need to specify a config handler for each type of the config request. Config Service Setup Config service uses CacheStore to improve performance, so we need an instance of CacheStore to build the config service. CacheStore store = new CacheStore('PARTITION'); Config configService = new Config(store); It's recommended that for one application, we use one global config service like this: public class MyConfig { private static Config configService; public static Config getConfig() { if(configService == null) { CacheStore store = new CacheStore('PARTITION_NAME'); configService = new Config(store); // set up the config service } return configService; } } During the setup, we need register config handlers. configService.onRead('/System/version', new SystemVersionFunc()); configService.onWrite('/System/version', new SystemVersionWriteFunc()); Config Handlers A config handler is actuall a Func. Here is how we implement a onRead handler. public class OnReadFunc extends Func { public override Object exec(Object arg) { Map params = (Map)arg; // Custom logic return 'config value'; } } The params are collected from the config request. For example, for a config request like this, Config request /System/version/1?type=String params will be collected as: { 'number' = '1', 'type' = 'String' } Here is how we implement a onWrite handler. public class OnWriteFunc extends Func { public override Object exec(Object arg1, Object arg2) { Map params = (Map)arg1; Map data = (Map)arg2; // Custom logic return null; } } Read Configuration After the config service is set up, we can use it globally to read configurations. String version = (String)configService.read('/System/version'); // equivalent to String version = (String)configService.get('/System/version'); By default, we can even specify what kind of data type we want to get. String version = (String)configService.read('/System/version?type=String'); Config.apex will convert the result configuration value according to the type you specified. Write Configuration We can write configurations too, using the config service. configService.write('/System/version', new Map{ 'value': '1.0.0' }); // equivalent to configService.put('/System/version', new Map{ 'value': '1.0.0' }); We can pass in both params from the request config url and the data of Map. Constructors | Constructor | Description | | ----------- | ----------- | | Config(CacheStore) | Create a config from the CacheStore | Common Methods | Method | Description | | ----------- | ----------- | | getConfigPaths() | Get all config paths | | get(String) | Get the config | | read(String) | Read the config | | put(String, Map&lt;String, Object&gt;) | Write the config | | write(String, Map&lt;String, Object&gt;) | Write the config | Setup Methods | Method | Description | | ----------- | ----------- | | onReadWrite(String, Boolean, String, Func, Func) | Register read/write handlers | | onReadWrite(String, Boolean, Func, Func) | Register read/write handlers | | onReadWrite(String, Func, Func) | Register read/write handlers | | onRead(String, Boolean, String, Func) | Register read handler | | onRead(String, Boolean, Func) | Register read handler | | onRead(String, Func) | Register read handler | | onWrite(String, Boolean, String, Func) | Register write handler | | onWrite(String, Boolean, Func) | Register write handler | | onWrite(String, Func) | Register write handler | ","srcFilePath":"src/pages/docs/Config/index.md","id":"Config","location":"/docs/Config/","url":"/config-apex/docs/Config/"},"SObjectHandler":{"title":"SObjectHandler","description":"SObjectHandler","layout":"guide","icon":"code-file","weight":2,"content":" {$page.description} SObjectHandler SObjectHandler provides easy integrations with SObjects and CustomSettings. To create a read handler, we can do this: configService.onRead('/System/CustomButton/list', new Config.SObjectHandler('CustomButton_c') .fetch('SELECT Id, Name FROM CustomButton_c') .then(R.pluck.apply('Name')) ); To create a write handler, we can do this: configService.onWrite('/System/CustomButton/new', new Config.SObjectHandler('CustomButton_c') .doInsert(new Map{ ... }); ); Methods | Method | Description | | ------ | ----------- | | SObjectHandler(String) | Create an instance with the object type | | fetch(String) | Get the records from the query | | then(Func) | Add the Func to process the data | | doInsert(Map&lt;String, Object&gt;) | Insert the data | | doUpdate(Map&lt;String, Object&gt;) | Update the records with the data | | doDelete() | Delete the records | ","srcFilePath":"src/pages/docs/SObjectHandler/index.md","id":"SObjectHandler","location":"/docs/SObjectHandler/","url":"/config-apex/docs/SObjectHandler/"},"CacheStore":{"title":"CacheStore","description":"CacheStore","layout":"guide","icon":"cloud","weight":4,"content":" {$page.description} CacheStore CacheStore provides a ready-to-use solution for cache management. According to Salesforce Platform Cache Best Practices, too many requests for small cached items are inefficient. A recommended way is to bundle these items into a large item to be cached. The problem is that we have a size limit for the single cached item. That means that we cannot put too huge an item into the cache. CacheStore is hence created to offer an elegant way to solve this. Inside CacheStore, we manage a list of bundles, each of them is a `Map","srcFilePath":"src/pages/docs/CacheStore/index.md","id":"CacheStore","location":"/docs/CacheStore/","url":"/config-apex/docs/CacheStore/"}},"childIds":["Config","SObjectHandler","CacheStore","search"]},"tutorials":{"title":"Tutorials","description":"The tutorials","url":"/config-apex/tutorials/getting_started/step_1.html","layout":false,"content":" ","srcFilePath":"src/pages/tutorials/index.soy","id":"tutorials","location":"/tutorials/","customURL":true,"children":{"getting_started":{"title":"Getting Started","description":"The Getting Started Tutorial","tutorialTitle":"Getting started with Config.apex","url":"/config-apex/tutorials/getting_started/step_1.html","layout":false,"content":" ","srcFilePath":"src/pages/tutorials/getting_started/index.soy","id":"getting_started","location":"/tutorials/getting_started/","customURL":true,"children":{"step_1":{"title":"Installation","description":"Include Apex files","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":1,"content":" {$page.title} Config.apex has a dependency on R.apex. First, we will include R.apex. Include Func.cls, R.cls, and RTest.cls(optional) into your Org, and R.apex is ready. Then, we will include Config.apex. Include CacheStore.cls, CacheStoreTest.cls(optional), Config.cls and ConfigTest.cls(optional) into your Org, and you are ready to go. ","srcFilePath":"src/pages/tutorials/getting_started/step_1.md","id":"step_1","location":"/tutorials/getting_started/step_1.html","url":"/config-apex/tutorials/getting_started/step_1.html"},"step_2":{"title":"Preliminary Knowledge","description":"Preliminary Knowledge","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":2,"content":" {$page.title} It's recommended that you have a fair amount of knowledge on R.apex, but it's not required. Config.apex uses Func objects from R.apex, and a Func is actually a custom Apex object that mimics the behavior of a function. Here is how your implement a custom Func. public class HelloWorldFunc extends Func { public HelloWorldFunc() { super(0); // specify the number of arguments the Func takes } // Provide custom implementation for a Func that takes 0 arguments. public override Object exec() { return 'Hello World'; } } And then you instantiate, and invoke it. Func helloworld = new HelloWorldFunc(); String msg = (String)helloworld.run(); To get deeper with Func objects, please check R.apex. ","srcFilePath":"src/pages/tutorials/getting_started/step_2.md","id":"step_2","location":"/tutorials/getting_started/step_2.html","url":"/config-apex/tutorials/getting_started/step_2.html"},"step_3":{"title":"Cache Management","description":"Cache Management","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":3,"content":" {$page.title} Once you have set up a cache partition, you can use CacheStore to easily access your cache. CacheStore store = new CacheStore('Your Partition'); store.OrgCache.put('key', 'value'); String value = (String)store.get('key'); Internally CacheStore will bundle single cache requests into a big cache request to improve the cache efficiency. If the cache bundle is too big for one request, CacheStore will split it into smaller bundles. Care is taken and you worry no more about the details of managing Salesforce Platform Cache. ","srcFilePath":"src/pages/tutorials/getting_started/step_3.md","id":"step_3","location":"/tutorials/getting_started/step_3.html","url":"/config-apex/tutorials/getting_started/step_3.html"},"step_4":{"title":"Config Service","description":"Config Service","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":4,"content":" {$page.title} Config service in Config.apex works as a single entry point to access the configurations. It is backed by CacheStore to provide high performance. Below is how we create an instance of the config service. CacheStore store = new CacheStore('PARTITION'); Config configService = new Config(store); ","srcFilePath":"src/pages/tutorials/getting_started/step_4.md","id":"step_4","location":"/tutorials/getting_started/step_4.html","url":"/config-apex/tutorials/getting_started/step_4.html"},"step_5":{"title":"Config Handlers","description":"Config Handlers","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":5,"content":" {$page.title} After creating the instance of the config service, we need to correctly set it up for use. A config service is a facade that accepts config requests on certain config urls, process the requests and send back the responses. It dispatches the config requests to config handlers to process. onfigService.onRead('/System/version', new SystemVersionFunc()); Here we registered a config handler SystemVersionFunc to process requests from config url /System/version. Also we can register config handlers to process requests to update configuration values. configService.onWrite('/System/version', new SystemVersionWriteFunc()); By default, config handlers work on the org cache. But we can specify them to work on the session cache too. configService.onRead('/System/version', true, Config.SCOPE_SESSION, new SystemVersionFunc()); Or even we can turn off the cache used by the config handlers, when sometimes we need to always get the update-to-date data. configService.onRead('/System/version', false, new SystemVersionFunc()); In case of complicated config requests, we also support parameterized url matching. public class CustomHandler extends Func { public override Object exec(Object arg) { Map params = (Map)arg; String version = params.get('version'); // Custom logic return 'config value'; } public override Object exec(Object arg1, Object arg2) { Map params = (Map)arg1; Map data = (Map)arg2; // Custom logic return null; } } Func handler = new CustomHandler(); configService.onReadWrite('/System/version/${version}', handler, handler); ","srcFilePath":"src/pages/tutorials/getting_started/step_5.md","id":"step_5","location":"/tutorials/getting_started/step_5.html","url":"/config-apex/tutorials/getting_started/step_5.html"},"step_6":{"title":"Read Configuration","description":"Read Configuration","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":6,"content":" {$page.title} After the config service is set up, we can use it globally to read configurations. String version = (String)configService.read('/System/version'); // equivalent to String version = (String)configService.get('/System/version'); By default, we can even specify what kind of data type we want to get. String version = (String)configService.read('/System/version?type=String'); Config.apex will convert the result configuration value according to the type you specified. ","srcFilePath":"src/pages/tutorials/getting_started/step_6.md","id":"step_6","location":"/tutorials/getting_started/step_6.html","url":"/config-apex/tutorials/getting_started/step_6.html"},"step_7":{"title":"Write Configuration","description":"Write Configuration","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":7,"content":" {$page.title} We can write configurations too, using the config service. configService.write('/System/version', new Map{ 'value': '1.0.0' }); // equivalent to configService.put('/System/version', new Map{ 'value': '1.0.0' }); We can pass in both params from the request config url and the data of Map. ","srcFilePath":"src/pages/tutorials/getting_started/step_7.md","id":"step_7","location":"/tutorials/getting_started/step_7.html","url":"/config-apex/tutorials/getting_started/step_7.html"},"step_8":{"title":"Integrations","description":"Integrations","buttonTitle":"Done","parentId":"getting_started","layout":"tutorial","time":90,"weight":8,"content":" {$page.title} Config.apex has a good integration with custom settings and SObjects. configService.onRead('/System/CustomButton/list', new Config.SObjectHandler('CustomButton_c') .fetch('SELECT Id, Name FROM CustomButton_c') .then(R.pluck.apply('Name')) ); SObjectHandler can be used to handle SObjects as well as custom setting objects, to easily manage query, insert, update and delete operations. ","srcFilePath":"src/pages/tutorials/getting_started/step_8.md","id":"step_8","location":"/tutorials/getting_started/step_8.html","url":"/config-apex/tutorials/getting_started/step_8.html"}},"childIds":["step_1","step_2","step_3","step_4","step_5","step_6","step_7","step_8"]}},"childIds":["getting_started"]}},"childIds":["docs","tutorials"]},"basePath":"/config-apex"}